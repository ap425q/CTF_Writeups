

# This file was *autogenerated* from the file solver.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1111 = Integer(1111); _sage_const_20 = Integer(20); _sage_const_48 = Integer(48); _sage_const_16 = Integer(16); _sage_const_100 = Integer(100); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2)
from pwn import *
from Crypto.Util.number import long_to_bytes,bytes_to_long
from sage.modules.free_module_integer import IntegerLattice
io=remote("34.30.232.46",int(_sage_const_1111 ))
io.recv()
data={"option":"encrypt","msgs":['00' for i in range(_sage_const_20 )]}
import json
param={"option":"parameters"}

io.sendline(json.dumps(param).encode())
param=json.loads(io.recvline().decode())
io.sendline(json.dumps({"option":"get_flag"}).encode())
print(io.recvline())
flag=json.loads(io.recvline().decode())["enc_flag"]

print(flag)
M=param["M"]
a=param["a"]
b=param["b"]

print(param)

data_enc=[]
data=json.dumps(data)
for i in range(_sage_const_48 ):
    io.recvuntil(b"to encrypt\n")
    io.sendline(data.encode())
    t=json.loads(io.recvuntil(b"}"))["encrypted_msgs"]
    data_enc.append(t)

data_enc=[[int(i,_sage_const_16 )<<_sage_const_100  for i in j] for j in data_enc]
summed_data=[]
for i in data_enc:
    p=_sage_const_0 
    for j in i:
        p=p+j
    summed_data.append(p)

x=var("x")
eq=[x]
n=_sage_const_48 
for i in range(n*_sage_const_20 ):
    eq.append(eq[-_sage_const_1 ]*a+b)
eq=eq[_sage_const_1 :]
eq=[eq[i:i+_sage_const_20 ] for i in range(_sage_const_0 ,n*_sage_const_20 ,_sage_const_20 )]
eq2=[]
for i in eq:
    qq=_sage_const_0 
    for j in i:
        qq+=j
    aa,bb=qq.coefficients()
    bb=int(int(bb[_sage_const_0 ])%M)
    aa=int(int(aa[_sage_const_0 ])%M)
    eq2.append([bb,aa])


# this code is from https://hackmd.io/@hakatashi/B1OM7HFVI

def Babai_closest_vector(M, G, target):
  small = target
  for _ in range(_sage_const_1 ):
    for i in reversed(range(M.nrows())):
      c = ((small * G[i]) / (G[i] * G[i])).round()
      small -= M[i] * c
  return target - small

A_values=[[i[_sage_const_0 ],_sage_const_1 ] for i in eq2]
b_values=[i-j[_sage_const_1 ] for i, j in zip(summed_data,eq2)]

q=M
n=_sage_const_2 
m=_sage_const_48 
A = matrix(ZZ, m + n, m)
for i in range(m):
  A[i, i] = q
for x in range(m):
  for y in range(n):
    A[m + y, x] = A_values[x][y]
  
lattice = IntegerLattice(A, lll_reduce=True)
print("LLL done")
gram = lattice.reduced_basis.gram_schmidt()[_sage_const_0 ]
target = vector(ZZ, b_values)
res = Babai_closest_vector(lattice.reduced_basis, gram, target)
print("Closest Vector: {}".format(res))
print(res)
R = IntegerModRing(q)

M = Matrix(R, A_values)
xx,random = M.solve_right(res)
xx=xx>>_sage_const_100 
xx=int(xx)
flag=int(flag,_sage_const_16 )
flag=xx^flag
print(long_to_bytes(int(flag)))
#BSidesIndore{MAStEr_Of_1cG_and_ShuFf1e?}

